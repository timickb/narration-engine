// Code generated by MockGen. DO NOT EDIT.
// Source: ../core/interfaces.go
//
// Generated by this command:
//
//	mockgen -package=mocks -source=../core/interfaces.go -destination=CoreMocks.go -mock_names=AsyncWorkerConfig=AsyncWorkerConfigMock,HandlerAdapter=HandlerAdapterMock,InstanceRepository=CoreInstanceRepositoryMock,TransitionRepository=CoreTransitionRepositoryMock
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	uuid "github.com/google/uuid"
	domain "github.com/timickb/narration-engine/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// AsyncWorkerConfigMock is a mock of AsyncWorkerConfig interface.
type AsyncWorkerConfigMock struct {
	ctrl     *gomock.Controller
	recorder *AsyncWorkerConfigMockMockRecorder
}

// AsyncWorkerConfigMockMockRecorder is the mock recorder for AsyncWorkerConfigMock.
type AsyncWorkerConfigMockMockRecorder struct {
	mock *AsyncWorkerConfigMock
}

// NewAsyncWorkerConfigMock creates a new mock instance.
func NewAsyncWorkerConfigMock(ctrl *gomock.Controller) *AsyncWorkerConfigMock {
	mock := &AsyncWorkerConfigMock{ctrl: ctrl}
	mock.recorder = &AsyncWorkerConfigMockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *AsyncWorkerConfigMock) EXPECT() *AsyncWorkerConfigMockMockRecorder {
	return m.recorder
}

// GetInstanceLockTimeout mocks base method.
func (m *AsyncWorkerConfigMock) GetInstanceLockTimeout() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInstanceLockTimeout")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// GetInstanceLockTimeout indicates an expected call of GetInstanceLockTimeout.
func (mr *AsyncWorkerConfigMockMockRecorder) GetInstanceLockTimeout() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstanceLockTimeout", reflect.TypeOf((*AsyncWorkerConfigMock)(nil).GetInstanceLockTimeout))
}

// GetLoadedScenario mocks base method.
func (m *AsyncWorkerConfigMock) GetLoadedScenario(name, version string) (*domain.Scenario, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLoadedScenario", name, version)
	ret0, _ := ret[0].(*domain.Scenario)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLoadedScenario indicates an expected call of GetLoadedScenario.
func (mr *AsyncWorkerConfigMockMockRecorder) GetLoadedScenario(name, version any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLoadedScenario", reflect.TypeOf((*AsyncWorkerConfigMock)(nil).GetLoadedScenario), name, version)
}

// GetLockerId mocks base method.
func (m *AsyncWorkerConfigMock) GetLockerId() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLockerId")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetLockerId indicates an expected call of GetLockerId.
func (mr *AsyncWorkerConfigMockMockRecorder) GetLockerId() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLockerId", reflect.TypeOf((*AsyncWorkerConfigMock)(nil).GetLockerId))
}

// HandlerAdapterMock is a mock of HandlerAdapter interface.
type HandlerAdapterMock struct {
	ctrl     *gomock.Controller
	recorder *HandlerAdapterMockMockRecorder
}

// HandlerAdapterMockMockRecorder is the mock recorder for HandlerAdapterMock.
type HandlerAdapterMockMockRecorder struct {
	mock *HandlerAdapterMock
}

// NewHandlerAdapterMock creates a new mock instance.
func NewHandlerAdapterMock(ctrl *gomock.Controller) *HandlerAdapterMock {
	mock := &HandlerAdapterMock{ctrl: ctrl}
	mock.recorder = &HandlerAdapterMockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *HandlerAdapterMock) EXPECT() *HandlerAdapterMockMockRecorder {
	return m.recorder
}

// CallHandler mocks base method.
func (m *HandlerAdapterMock) CallHandler(ctx context.Context, dto *domain.CallHandlerDto) (*domain.CallHandlerResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CallHandler", ctx, dto)
	ret0, _ := ret[0].(*domain.CallHandlerResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CallHandler indicates an expected call of CallHandler.
func (mr *HandlerAdapterMockMockRecorder) CallHandler(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CallHandler", reflect.TypeOf((*HandlerAdapterMock)(nil).CallHandler), ctx, dto)
}

// CoreInstanceRepositoryMock is a mock of InstanceRepository interface.
type CoreInstanceRepositoryMock struct {
	ctrl     *gomock.Controller
	recorder *CoreInstanceRepositoryMockMockRecorder
}

// CoreInstanceRepositoryMockMockRecorder is the mock recorder for CoreInstanceRepositoryMock.
type CoreInstanceRepositoryMockMockRecorder struct {
	mock *CoreInstanceRepositoryMock
}

// NewCoreInstanceRepositoryMock creates a new mock instance.
func NewCoreInstanceRepositoryMock(ctrl *gomock.Controller) *CoreInstanceRepositoryMock {
	mock := &CoreInstanceRepositoryMock{ctrl: ctrl}
	mock.recorder = &CoreInstanceRepositoryMockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *CoreInstanceRepositoryMock) EXPECT() *CoreInstanceRepositoryMockMockRecorder {
	return m.recorder
}

// FetchWithLock mocks base method.
func (m *CoreInstanceRepositoryMock) FetchWithLock(ctx context.Context, dto *domain.FetchInstanceDto) (*domain.Instance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchWithLock", ctx, dto)
	ret0, _ := ret[0].(*domain.Instance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchWithLock indicates an expected call of FetchWithLock.
func (mr *CoreInstanceRepositoryMockMockRecorder) FetchWithLock(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchWithLock", reflect.TypeOf((*CoreInstanceRepositoryMock)(nil).FetchWithLock), ctx, dto)
}

// GetWaitingIds mocks base method.
func (m *CoreInstanceRepositoryMock) GetWaitingIds(ctx context.Context, limit int) ([]uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWaitingIds", ctx, limit)
	ret0, _ := ret[0].([]uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWaitingIds indicates an expected call of GetWaitingIds.
func (mr *CoreInstanceRepositoryMockMockRecorder) GetWaitingIds(ctx, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWaitingIds", reflect.TypeOf((*CoreInstanceRepositoryMock)(nil).GetWaitingIds), ctx, limit)
}

// Unlock mocks base method.
func (m *CoreInstanceRepositoryMock) Unlock(ctx context.Context, id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unlock", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unlock indicates an expected call of Unlock.
func (mr *CoreInstanceRepositoryMockMockRecorder) Unlock(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlock", reflect.TypeOf((*CoreInstanceRepositoryMock)(nil).Unlock), ctx, id)
}

// Update mocks base method.
func (m *CoreInstanceRepositoryMock) Update(ctx context.Context, instance *domain.Instance) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, instance)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *CoreInstanceRepositoryMockMockRecorder) Update(ctx, instance any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*CoreInstanceRepositoryMock)(nil).Update), ctx, instance)
}

// CoreTransitionRepositoryMock is a mock of TransitionRepository interface.
type CoreTransitionRepositoryMock struct {
	ctrl     *gomock.Controller
	recorder *CoreTransitionRepositoryMockMockRecorder
}

// CoreTransitionRepositoryMockMockRecorder is the mock recorder for CoreTransitionRepositoryMock.
type CoreTransitionRepositoryMockMockRecorder struct {
	mock *CoreTransitionRepositoryMock
}

// NewCoreTransitionRepositoryMock creates a new mock instance.
func NewCoreTransitionRepositoryMock(ctrl *gomock.Controller) *CoreTransitionRepositoryMock {
	mock := &CoreTransitionRepositoryMock{ctrl: ctrl}
	mock.recorder = &CoreTransitionRepositoryMockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *CoreTransitionRepositoryMock) EXPECT() *CoreTransitionRepositoryMockMockRecorder {
	return m.recorder
}

// GetLastForInstance mocks base method.
func (m *CoreTransitionRepositoryMock) GetLastForInstance(ctx context.Context, instanceId uuid.UUID) (*domain.SavedTransition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLastForInstance", ctx, instanceId)
	ret0, _ := ret[0].(*domain.SavedTransition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLastForInstance indicates an expected call of GetLastForInstance.
func (mr *CoreTransitionRepositoryMockMockRecorder) GetLastForInstance(ctx, instanceId any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLastForInstance", reflect.TypeOf((*CoreTransitionRepositoryMock)(nil).GetLastForInstance), ctx, instanceId)
}

// Save mocks base method.
func (m *CoreTransitionRepositoryMock) Save(ctx context.Context, dto *domain.SaveTransitionDto) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx, dto)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Save indicates an expected call of Save.
func (mr *CoreTransitionRepositoryMockMockRecorder) Save(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*CoreTransitionRepositoryMock)(nil).Save), ctx, dto)
}

// SetError mocks base method.
func (m *CoreTransitionRepositoryMock) SetError(ctx context.Context, transitionId uuid.UUID, errText string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetError", ctx, transitionId, errText)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetError indicates an expected call of SetError.
func (mr *CoreTransitionRepositoryMockMockRecorder) SetError(ctx, transitionId, errText any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetError", reflect.TypeOf((*CoreTransitionRepositoryMock)(nil).SetError), ctx, transitionId, errText)
}
