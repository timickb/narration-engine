// Code generated by MockGen. DO NOT EDIT.
// Source: ../usecase/interfaces.go
//
// Generated by this command:
//
//	mockgen -package=mocks -source=../usecase/interfaces.go -destination=UsecaseMocks.go -mock_names=InstanceRepository=UsecaseInstanceRepositoryMock,PendingEventRepository=UsecasePendingEventRepositoryMock,Config=UsecaseConfigMock
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	uuid "github.com/google/uuid"
	domain "github.com/timickb/narration-engine/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// UsecaseInstanceRepositoryMock is a mock of InstanceRepository interface.
type UsecaseInstanceRepositoryMock struct {
	ctrl     *gomock.Controller
	recorder *UsecaseInstanceRepositoryMockMockRecorder
}

// UsecaseInstanceRepositoryMockMockRecorder is the mock recorder for UsecaseInstanceRepositoryMock.
type UsecaseInstanceRepositoryMockMockRecorder struct {
	mock *UsecaseInstanceRepositoryMock
}

// NewUsecaseInstanceRepositoryMock creates a new mock instance.
func NewUsecaseInstanceRepositoryMock(ctrl *gomock.Controller) *UsecaseInstanceRepositoryMock {
	mock := &UsecaseInstanceRepositoryMock{ctrl: ctrl}
	mock.recorder = &UsecaseInstanceRepositoryMockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *UsecaseInstanceRepositoryMock) EXPECT() *UsecaseInstanceRepositoryMockMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *UsecaseInstanceRepositoryMock) Create(ctx context.Context, dto *domain.CreateInstanceDto) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, dto)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *UsecaseInstanceRepositoryMockMockRecorder) Create(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*UsecaseInstanceRepositoryMock)(nil).Create), ctx, dto)
}

// GetById mocks base method.
func (m *UsecaseInstanceRepositoryMock) GetById(ctx context.Context, id uuid.UUID) (*domain.Instance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetById", ctx, id)
	ret0, _ := ret[0].(*domain.Instance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetById indicates an expected call of GetById.
func (mr *UsecaseInstanceRepositoryMockMockRecorder) GetById(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetById", reflect.TypeOf((*UsecaseInstanceRepositoryMock)(nil).GetById), ctx, id)
}

// IsKeyBlocked mocks base method.
func (m *UsecaseInstanceRepositoryMock) IsKeyBlocked(ctx context.Context, key string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsKeyBlocked", ctx, key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsKeyBlocked indicates an expected call of IsKeyBlocked.
func (mr *UsecaseInstanceRepositoryMockMockRecorder) IsKeyBlocked(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsKeyBlocked", reflect.TypeOf((*UsecaseInstanceRepositoryMock)(nil).IsKeyBlocked), ctx, key)
}

// UsecasePendingEventRepositoryMock is a mock of PendingEventRepository interface.
type UsecasePendingEventRepositoryMock struct {
	ctrl     *gomock.Controller
	recorder *UsecasePendingEventRepositoryMockMockRecorder
}

// UsecasePendingEventRepositoryMockMockRecorder is the mock recorder for UsecasePendingEventRepositoryMock.
type UsecasePendingEventRepositoryMockMockRecorder struct {
	mock *UsecasePendingEventRepositoryMock
}

// NewUsecasePendingEventRepositoryMock creates a new mock instance.
func NewUsecasePendingEventRepositoryMock(ctrl *gomock.Controller) *UsecasePendingEventRepositoryMock {
	mock := &UsecasePendingEventRepositoryMock{ctrl: ctrl}
	mock.recorder = &UsecasePendingEventRepositoryMockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *UsecasePendingEventRepositoryMock) EXPECT() *UsecasePendingEventRepositoryMockMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *UsecasePendingEventRepositoryMock) Create(ctx context.Context, dto *domain.CreatePendingEventDto) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, dto)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *UsecasePendingEventRepositoryMockMockRecorder) Create(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*UsecasePendingEventRepositoryMock)(nil).Create), ctx, dto)
}

// UsecaseConfigMock is a mock of Config interface.
type UsecaseConfigMock struct {
	ctrl     *gomock.Controller
	recorder *UsecaseConfigMockMockRecorder
}

// UsecaseConfigMockMockRecorder is the mock recorder for UsecaseConfigMock.
type UsecaseConfigMockMockRecorder struct {
	mock *UsecaseConfigMock
}

// NewUsecaseConfigMock creates a new mock instance.
func NewUsecaseConfigMock(ctrl *gomock.Controller) *UsecaseConfigMock {
	mock := &UsecaseConfigMock{ctrl: ctrl}
	mock.recorder = &UsecaseConfigMockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *UsecaseConfigMock) EXPECT() *UsecaseConfigMockMockRecorder {
	return m.recorder
}

// GetLoadedScenario mocks base method.
func (m *UsecaseConfigMock) GetLoadedScenario(name, version string) (*domain.Scenario, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLoadedScenario", name, version)
	ret0, _ := ret[0].(*domain.Scenario)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLoadedScenario indicates an expected call of GetLoadedScenario.
func (mr *UsecaseConfigMockMockRecorder) GetLoadedScenario(name, version any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLoadedScenario", reflect.TypeOf((*UsecaseConfigMock)(nil).GetLoadedScenario), name, version)
}
